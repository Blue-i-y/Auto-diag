# Importation des modules nécessaires pour le fonctionnement du script.
import os
import requests
import sys
from urllib.parse import urlparse
sys.path.append('../')  # Ajoute le chemin du répertoire parent au sys.path pour l'importation de modules.
import utiles  # Importation du module utiles qui doit contenir des fonctions ou classes supplémentaires.

def is_valid_url(url):
    # Valide l'URL en vérifiant son schéma et son emplacement réseau.
    try:
        result = urlparse(url)  # Parse l'URL pour extraire ses composants.
        return all([result.scheme, result.netloc]) and (result.scheme in ['http', 'https'])
    except ValueError:
        return False  # Retourne False si l'URL est mal formée et soulève une ValueError.

def check_subdomains(wordlist, domain):
    # Fonction pour tester les sous-domaines d'un domaine donné à partir d'une liste de mots (wordlist).
    try:
        with open(wordlist, 'r') as f:  # Ouvre le fichier de wordlist en mode lecture.
            sub_list = f.read().splitlines()  # Lit et sépare les mots dans une liste de sous-domaines.
    except FileNotFoundError:
        print("Wordlist not found.")  # Gère l'erreur si le fichier wordlist n'est pas trouvé.
        sys.exit(1)

    # Vérifie si le domaine est bien formaté avec http ou https.
    if not domain.startswith("http://") and not domain.startswith("https://"):
        print("Invalid domain format. Please enter the domain in the format: http://host/ or https://host/")
        sys.exit(1)

    total_subdomains = len(sub_list)  # Nombre total de sous-domaines à tester.
    tested_subdomains = 0  # Compteur pour les sous-domaines déjà testés.

    for sub in sub_list:
        sub_domain = f"{sub}.{domain.split('://')[1]}"  # Forme le sous-domaine complet.
        tested_subdomains += 1
        completion_percentage = (tested_subdomains / total_subdomains) * 100
        os.system('cls' if os.name == 'nt' else 'clear')  # Nettoie la console pour afficher la progression.
        print(f"Test en cours : {completion_percentage:.2f}%")
        print(f"Sous-domaines testés : {sub_domain}\n{tested_subdomains}/{total_subdomains}")
        if not sub or not sub.isalnum(): 
            continue  # Ignore les entrées vides ou non alphanumériques.

        # Formate correctement l'URL complète du sous-domaine.
        if domain.startswith("http://"):
            sub = f"http://{sub}"
        if domain.startswith("https://"):
            sub = f"https://{sub}"

        if not is_valid_url(sub_domain):
            continue  # Continue la boucle si l'URL n'est pas valide.

        try:
            response = requests.get(sub_domain)  # Effectue une requête HTTP GET.
            if response.status_code == 200:
                print("\rValid domain:", sub_domain)  # Affiche le domaine valide.
            elif response.status_code == 403:
                print_orange("\rAccess Forbidden:", sub_domain)  # Affiche un message si l'accès est interdit.
        except requests.ConnectionError:
            pass  # Ignore les erreurs de connexion.

    print()

def main():
    # Fonction principale pour gérer les arguments de ligne de commande et lancer la vérification des sous-domaines.
    if len(sys.argv) != 2 and len(sys.argv) != 3:
        print("Usage: python SubEnum.py <domain> [<wordlist_file>]")  # Message d'aide pour l'utilisation du script.
        sys.exit(1)

    domain = sys.argv[1]  # Domaine passé en argument.

    # Choix du fichier wordlist en fonction du nombre d'arguments.
    if len(sys.argv) == 3:
        wordlist = sys.argv[2]  # Utilisation du fichier wordlist spécifié par l'utilisateur.
    elif len(sys.argv) == 2:
        wordlist = "/usr/share/wordlists/dirb/common.txt"  # Utilisation d'un fichier wordlist par défaut.

    check_subdomains(wordlist, domain)  # Appel de la fonction pour tester les sous-domaines.

if __name__ == "__main__":
    main()  # Exécute la fonction principale si le script est lancé directement.
